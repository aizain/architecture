# 第一天

```
mysql 索引
```

## mysql - 读取数据问题

> 图形工具
```
navicat
```

> 查询追求目标
```
可控
```

> mysql性能缺陷
```
1. 表扫描 - 上周五内容
2. 读取数据 - 磁盘IO - 使用分页
```

> 示例
```
第一种： // 正常查询时，这种更快
SELECT * FROM user
WHERE id in (1,2,3,4,5,6,7,8,9,10);

第二种： // 可控，当查询数据不在一个表里
SELECT * FROM user
WHERE id = 1;
SELECT * FROM user
WHERE id = 2;
SELECT * FROM user
WHERE id = 3;
...
SELECT * FROM user
WHERE id = 10;


时间不同点：
直接精确到id查询，不需要编译解释时间
发送数据的时间
磁盘读取记录数量时间
```

## 索引表
> 案例
```
1000w用户
查询 用户，祖籍在河北，在北京工作


SELECT * FROM 

建表:
user 
id uid username pwd relname sex city ...

index_user - 针对特定搜索业务 - 一定时间内更新 - 原则上都建立索引
id uid city age ... 
```

> 表规范 推荐
```
元数据表 data_ 不会修改的表
索引表 index_ 高频操作，单表难以完成，不需要保存元数据的精确信息
关联表 rel_
统计汇总信息表 count_
```

> 索引表
```
高频操作，单表难以完成，不需要保存元数据的精确信息
95% 跟搜索有关
需要支撑10w用户以上，需要索引表
```

> 冒泡算法
```
省内存 时间长
```

> 案例
```
1万写入操作/秒
100万查询操作/秒
是否要建索引
读比写大很多倍，但是写也很多

解决方案 - 下节课

一种解决思路，元数据只留主键索引
```

作业：
```
1. 疑问
当数据不在一个表，那种查询好
多数据库，包含冗余数据，那种查询好
```